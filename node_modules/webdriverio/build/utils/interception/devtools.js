"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const atob_1 = __importDefault(require("atob"));
const minimatch_1 = __importDefault(require("minimatch"));
const logger_1 = __importDefault(require("@wdio/logger"));
const _1 = __importDefault(require("."));
const __1 = require("..");
const constants_1 = require("../../constants");
const log = logger_1.default('webdriverio');
class DevtoolsInterception extends _1.default {
    static handleRequestInterception(client, mocks) {
        return async (event) => {
            // responseHeaders and responseStatusCode are only present in Response stage
            // https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#event-requestPaused
            const isRequest = !event.responseHeaders;
            const eventResponseHeaders = event.responseHeaders || [];
            const responseHeaders = eventResponseHeaders.reduce((headers, { name, value }) => {
                headers[name] = value;
                return headers;
            }, {});
            const { requestId, request, responseStatusCode = 200 } = event;
            for (const mock of mocks) {
                /**
                 * skip response mocks in Request stage
                 */
                if (isRequest && (mock.respondOverwrites.length === 0 || // nothing to do in Request stage
                    (!mock.respondOverwrites[0].errorReason && // skip if not going to abort a request
                        // or want to fetch response
                        mock.respondOverwrites[0].params &&
                        mock.respondOverwrites[0].params.fetchResponse !== false))) {
                    continue;
                }
                /**
                 * match mock url
                 */
                if (!minimatch_1.default(request.url, mock.url)) {
                    continue;
                }
                /**
                 * Add statusCode and responseHeaders to request to be used in expect-webdriverio
                 */
                request.statusCode = responseStatusCode;
                request.responseHeaders = { ...responseHeaders };
                /**
                 * match filter options
                 */
                if (filterMethod(request.method, mock.filterOptions.method) ||
                    filterHeaders(request.headers, mock.filterOptions.requestHeaders) ||
                    filterHeaders(responseHeaders, mock.filterOptions.headers) ||
                    filterRequest(request.postData, mock.filterOptions.postData) ||
                    filterStatusCode(responseStatusCode, mock.filterOptions.statusCode)) {
                    continue;
                }
                const { body, base64Encoded = undefined } = isRequest ? { body: '' } : await client.send('Fetch.getResponseBody', { requestId }).catch(/* istanbul ignore next */ () => ({}));
                request.body = base64Encoded ? atob_1.default(body) : body;
                const contentTypeHeader = Object.keys(responseHeaders).find(h => h.toLowerCase() === 'content-type') || '';
                const responseContentType = responseHeaders[contentTypeHeader];
                request.body = responseContentType && responseContentType.includes('application/json')
                    ? tryParseJson(request.body)
                    : request.body;
                mock.matches.push(request);
                /**
                 * no stubbing if no overwrites were defined
                 */
                if (mock.respondOverwrites.length === 0) {
                    continue;
                }
                const { errorReason, overwrite, params = {} } = mock.respondOverwrites[0].sticky
                    ? mock.respondOverwrites[0]
                    : mock.respondOverwrites.shift() || {};
                /**
                 * when response is modified
                 */
                if (overwrite !== undefined) {
                    let newBody = overwrite;
                    if (typeof overwrite === 'function') {
                        newBody = await overwrite(request, client);
                    }
                    const isBodyUndefined = typeof newBody === 'undefined';
                    if (isBodyUndefined) {
                        newBody = '';
                    }
                    if (typeof newBody !== 'string') {
                        newBody = JSON.stringify(newBody);
                    }
                    let responseCode = typeof params.statusCode === 'function' ? params.statusCode(request) : params.statusCode || responseStatusCode;
                    let responseHeaders = [
                        ...eventResponseHeaders,
                        ...Object.entries(typeof params.headers === 'function' ? params.headers(request) : params.headers || {}).map(([name, value]) => ({ name, value }))
                    ];
                    /**
                     * check if local file and load it
                     */
                    const responseFilePath = path_1.default.isAbsolute(newBody) ? newBody : path_1.default.join(process.cwd(), newBody);
                    if (newBody.length > 0 && await fs_extra_1.default.pathExists(responseFilePath) && await canAccess(responseFilePath)) {
                        newBody = await fs_extra_1.default.readFile(responseFilePath);
                    }
                    else if (newBody.startsWith('http')) {
                        responseCode = 301;
                        /**
                         * filter out possible available location header
                         */
                        responseHeaders = responseHeaders.filter(({ name }) => name.toLowerCase() !== 'location');
                        responseHeaders.push({ name: 'Location', value: newBody });
                    }
                    request.mockedResponse = newBody;
                    return client.send('Fetch.fulfillRequest', {
                        requestId,
                        responseCode,
                        responseHeaders,
                        /** do not mock body if it's undefined */
                        body: isBodyUndefined ? undefined : (newBody instanceof Buffer ? newBody : Buffer.from(newBody, 'utf8')).toString('base64')
                    }).catch(/* istanbul ignore next */ logFetchError);
                }
                /**
                 * when request is aborted
                 */
                if (errorReason) {
                    return client.send('Fetch.failRequest', {
                        requestId,
                        errorReason
                    }).catch(/* istanbul ignore next */ logFetchError);
                }
            }
            return client.send('Fetch.continueRequest', { requestId }).catch(/* istanbul ignore next */ logFetchError);
        };
    }
    /**
     * allows access to all requests made with given pattern
     */
    get calls() {
        return this.matches;
    }
    /**
     * Resets all information stored in the `mock.calls` set.
     */
    clear() {
        this.matches = [];
    }
    /**
     * Does everything that `mock.clear()` does, and also
     * removes any mocked return values or implementations.
     */
    restore() {
        this.clear();
        this.respondOverwrites = [];
    }
    /**
     * Always respond with same overwrite
     * @param {*} overwrites  payload to overwrite the response
     * @param {*} params      additional respond parameters to overwrite
     */
    respond(overwrite, params = {}) {
        this.respondOverwrites.push({ overwrite, params, sticky: true });
    }
    /**
     * Respond request once with given overwrite
     * @param {*} overwrites  payload to overwrite the response
     * @param {*} params      additional respond parameters to overwrite
     */
    respondOnce(overwrite, params = {}) {
        this.respondOverwrites.push({ overwrite, params });
    }
    /**
     * Abort the request with an error code
     * @param {string} errorCode  error code of the response
     */
    abort(errorReason, sticky = true) {
        if (typeof errorReason !== 'string' || !constants_1.ERROR_REASON.includes(errorReason)) {
            throw new Error(`Invalid value for errorReason, allowed are: ${constants_1.ERROR_REASON.join(', ')}`);
        }
        this.respondOverwrites.push({ errorReason, sticky });
    }
    /**
     * Abort the request once with an error code
     * @param {string} errorReason  error code of the response
     */
    abortOnce(errorReason) {
        this.abort(errorReason, false);
    }
}
exports.default = DevtoolsInterception;
const filterMethod = (method, expected) => {
    if (typeof expected === 'undefined') {
        return false;
    }
    if (typeof expected === 'function') {
        return expected(method) !== true;
    }
    return expected.toLowerCase() !== method.toLowerCase();
};
const filterHeaders = (responseHeaders, expected) => {
    if (typeof expected === 'undefined') {
        return false;
    }
    if (typeof expected === 'function') {
        return expected(responseHeaders) !== true;
    }
    return !__1.containsHeaderObject(responseHeaders, expected);
};
const filterRequest = (postData, expected) => {
    if (typeof expected === 'undefined') {
        return false;
    }
    if (typeof expected === 'function') {
        return expected(postData) !== true;
    }
    return postData !== expected;
};
const filterStatusCode = (statusCode, expected) => {
    if (typeof expected === 'undefined') {
        return false;
    }
    if (typeof expected === 'function') {
        return expected(statusCode) !== true;
    }
    return statusCode !== expected;
};
/**
 * Helper utility to check file access
 * @param {String} file file to check access for
 * @return              Promise<true> if file can be accessed
 */
const canAccess = async (filepath) => {
    try {
        await fs_extra_1.default.access(filepath);
        return true;
    }
    catch {
        return false;
    }
};
const tryParseJson = (body) => {
    try {
        return JSON.parse(body) || body;
    }
    catch {
        return body;
    }
};
const logFetchError = (err) => {
    /* istanbul ignore next */
    log.debug(err === null || err === void 0 ? void 0 : err.message);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV2dG9vbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvaW50ZXJjZXB0aW9uL2RldnRvb2xzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsd0RBQTBCO0FBQzFCLGdEQUF1QjtBQUN2QixnREFBdUI7QUFDdkIsMERBQWlDO0FBSWpDLDBEQUFpQztBQUNqQyx5Q0FBNEI7QUFFNUIsMEJBQXlDO0FBQ3pDLCtDQUE4QztBQUU5QyxNQUFNLEdBQUcsR0FBRyxnQkFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFBO0FBcUJqQyxNQUFxQixvQkFBcUIsU0FBUSxVQUFZO0lBQzFELE1BQU0sQ0FBQyx5QkFBeUIsQ0FBRSxNQUFrQixFQUFFLEtBQXdCO1FBQzFFLE9BQU8sS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ25CLDRFQUE0RTtZQUM1RSxvRkFBb0Y7WUFDcEYsTUFBTSxTQUFTLEdBQUcsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFBO1lBQ3hDLE1BQU0sb0JBQW9CLEdBQUcsS0FBSyxDQUFDLGVBQWUsSUFBSSxFQUFFLENBQUE7WUFDeEQsTUFBTSxlQUFlLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUU7Z0JBQzdFLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUE7Z0JBQ3JCLE9BQU8sT0FBTyxDQUFBO1lBQ2xCLENBQUMsRUFBRSxFQUE0QixDQUFDLENBQUE7WUFDaEMsTUFBTSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEdBQUcsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBO1lBRTlELEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO2dCQUN0Qjs7bUJBRUc7Z0JBQ0gsSUFBSSxTQUFTLElBQUksQ0FDYixJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxLQUFLLENBQUMsSUFB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