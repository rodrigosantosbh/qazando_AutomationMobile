"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSync = exports.executeAsync = exports.executeSync = exports.hasWdioSyncSupport = exports.wrapCommand = exports.runFnInFiberContext = exports.executeHooksWithArgs = void 0;
const logger_1 = __importDefault(require("@wdio/logger"));
// import { BrowserObject } from 'webdriverio'
const log = logger_1.default('@wdio/utils:shim');
let inCommandHook = false;
let hasWdioSyncSupport = false;
exports.hasWdioSyncSupport = hasWdioSyncSupport;
let runSync;
exports.runSync = runSync;
let executeHooksWithArgs = async function executeHooksWithArgsShim(hookName, hooks = [], args = []) {
    /**
     * make sure hooks are an array of functions
     */
    if (!Array.isArray(hooks)) {
        hooks = [hooks];
    }
    /**
     * make sure args is an array since we are calling apply
     */
    if (!Array.isArray(args)) {
        args = [args];
    }
    const hooksPromises = hooks.map((hook) => new Promise((resolve) => {
        let result;
        try {
            result = hook.apply(null, args);
        }
        catch (e) {
            log.error(e.stack);
            return resolve(e);
        }
        /**
         * if a promise is returned make sure we don't have a catch handler
         * so in case of a rejection it won't cause the hook to fail
         */
        if (result && typeof result.then === 'function') {
            return result.then(resolve, (e) => {
                log.error(e.stack);
                resolve(e);
            });
        }
        resolve(result);
    }));
    const start = Date.now();
    const result = await Promise.all(hooksPromises);
    if (hooksPromises.length) {
        log.debug(`Finished to run "${hookName}" hook in ${Date.now() - start}ms`);
    }
    return result;
};
exports.executeHooksWithArgs = executeHooksWithArgs;
let runFnInFiberContext = function (fn) {
    return function (...args) {
        return Promise.resolve(fn.apply(this, args));
    };
};
exports.runFnInFiberContext = runFnInFiberContext;
/**
 * wrap command to enable before and after command to be executed
 * @param commandName name of the command (e.g. getTitle)
 * @param fn          command function
 */
let wrapCommand = function wrapCommand(commandName, fn) {
    return async function wrapCommandFn(...args) {
        const beforeHookArgs = [commandName, args];
        if (!inCommandHook && this.options.beforeCommand) {
            inCommandHook = true;
            await executeHooksWithArgs.call(this, 'beforeCommand', this.options.beforeCommand, beforeHookArgs);
            inCommandHook = false;
        }
        let commandResult;
        let commandError;
        try {
            commandResult = await fn.apply(this, args);
        }
        catch (err) {
            commandError = err;
        }
        if (!inCommandHook && this.options.afterCommand) {
            inCommandHook = true;
            const afterHookArgs = [...beforeHookArgs, commandResult, commandError];
            await executeHooksWithArgs.call(this, 'afterCommand', this.options.afterCommand, afterHookArgs);
            inCommandHook = false;
        }
        if (commandError) {
            throw commandError;
        }
        return commandResult;
    };
};
exports.wrapCommand = wrapCommand;
/**
 * execute test or hook synchronously
 *
 * @param  {Function} fn         spec or hook method
 * @param  {Number}   retries    { limit: number, attempts: number }
 * @param  {Array}    args       arguments passed to hook
 * @return {Promise}             that gets resolved once test/hook is done or was retried enough
 */
async function executeSyncFn(fn, retries, args = []) {
    this.wdioRetries = retries.attempts;
    try {
        let res = fn.apply(this, args);
        /**
         * sometimes function result is Promise,
         * we need to await result before proceeding
         */
        if (res instanceof Promise) {
            return await res;
        }
        return res;
    }
    catch (e) {
        if (retries.limit > retries.attempts) {
            retries.attempts++;
            return await executeSync.call(this, fn, retries, args);
        }
        return Promise.reject(e);
    }
}
/**
 * execute test or hook asynchronously
 *
 * @param  {Function} fn         spec or hook method
 * @param  {object}   retries    { limit: number, attempts: number }
 * @param  {Array}    args       arguments passed to hook
 * @return {Promise}             that gets resolved once test/hook is done or was retried enough
 */
async function executeAsync(fn, retries, args = []) {
    this.wdioRetries = retries.attempts;
    try {
        return await fn.apply(this, args);
    }
    catch (e) {
        if (retries.limit > retries.attempts) {
            retries.attempts++;
            return await executeAsync.call(this, fn, retries, args);
        }
        throw e;
    }
}
exports.executeAsync = executeAsync;
let executeSync = executeSyncFn;
exports.executeSync = executeSync;
/**
 * shim to make sure that we only wrap commands if wdio-sync is installed as dependency
 */
try {
    /**
     * only require `@wdio/sync` if `WDIO_NO_SYNC_SUPPORT` which allows us to
     * create a smoke test scenario to test actual absence of the package
     * (internal use only)
     */
    /* istanbul ignore if */
    if (!process.env.WDIO_NO_SYNC_SUPPORT) {
        const packageName = '@wdio/sync';
        const wdioSync = require(packageName);
        exports.hasWdioSyncSupport = hasWdioSyncSupport = true;
        exports.runFnInFiberContext = runFnInFiberContext = wdioSync.runFnInFiberContext;
        exports.wrapCommand = wrapCommand = wdioSync.wrapCommand;
        exports.executeHooksWithArgs = executeHooksWithArgs = wdioSync.executeHooksWithArgs;
        exports.executeSync = executeSync = wdioSync.executeSync;
        exports.runSync = runSync = wdioSync.runSync;
    }
}
catch {
    // do nothing
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hpbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zaGltLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDBEQUFpQztBQUVqQyw4Q0FBOEM7QUFFOUMsTUFBTSxHQUFHLEdBQUcsZ0JBQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO0FBRXRDLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQTtBQUN6QixJQUFJLGtCQUFrQixHQUFHLEtBQUssQ0FBQTtBQXdMMUIsZ0RBQWtCO0FBdkx0QixJQUFJLE9BQTRILENBQUE7QUEwTDVILDBCQUFPO0FBbkxYLElBQUksb0JBQW9CLEdBQUcsS0FBSyxVQUFVLHdCQUF3QixDQUFLLFFBQWdCLEVBQUUsUUFBK0IsRUFBRSxFQUFFLE9BQWMsRUFBRTtJQUN4STs7T0FFRztJQUNILElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLEtBQUssR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO0tBQ2xCO0lBRUQ7O09BRUc7SUFDSCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN0QixJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQTtLQUNoQjtJQUVELE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFZLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDekUsSUFBSSxNQUFNLENBQUE7UUFFVixJQUFJO1lBQ0EsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO1NBQ2xDO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUNsQixPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtTQUNwQjtRQUVEOzs7V0FH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