"use strict";
/**
 * used to wrap mocha, jasmine test frameworks functions (`it`, `beforeEach` and other)
 * with WebdriverIO before/after Test/Hook hooks.
 * Entrypoint is `runTestInFiberContext`, other functions are exported for testing purposes.
 *
 * NOTE: not used by cucumber test framework. `testFnWrapper` is called directly there
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runTestInFiberContext = exports.wrapTestFunction = exports.runSpec = exports.runHook = void 0;
const utils_1 = require("../utils");
const testFnWrapper_1 = require("./testFnWrapper");
const MOCHA_COMMANDS = ['skip', 'only'];
/**
 * runs a hook within fibers context (if function name is not async)
 * it also executes before/after hook
 *
 * @param  {Function} hookFn        function that was passed to the framework hook
 * @param  {Function} origFn        original framework hook function
 * @param  {Function} beforeFn      before hook
 * @param  {Function} beforeFnArgs  function that returns args for `beforeFn`
 * @param  {Function} afterFn       after hook
 * @param  {Function} afterArgsFn   function that returns args for `afterFn`
 * @param  {String}   cid           cid
 * @param  {Number}   repeatTest    number of retries if hook fails
 * @return {Function}               wrapped framework hook function
 */
exports.runHook = function (hookFn, origFn, beforeFn, beforeFnArgs, afterFn, afterFnArgs, cid, repeatTest) {
    return origFn(function (...hookFnArgs) {
        return testFnWrapper_1.testFnWrapper.call(this, 'Hook', {
            specFn: hookFn,
            specFnArgs: utils_1.filterSpecArgs(hookFnArgs)
        }, {
            beforeFn,
            beforeFnArgs
        }, {
            afterFn,
            afterFnArgs
        }, cid, repeatTest);
    });
};
/**
 * runs a spec function (test function) within the fibers context
 *
 * @param  {string}   specTitle     test description
 * @param  {Function} specFn        test function that got passed in from the user
 * @param  {Function} origFn        original framework test function
 * @param  {Function} beforeFn      before hook
 * @param  {Function} beforeFnArgs  function that returns args for `beforeFn`
 * @param  {Function} afterFn       after hook
 * @param  {Function} afterFnArgs   function that returns args for `afterFn`
 * @param  {String}   cid           cid
 * @param  {Number}   repeatTest    number of retries if test fails
 * @return {Function}               wrapped test function
 */
exports.runSpec = function (specTitle, specFn, origFn, beforeFn, beforeFnArgs, afterFn, afterFnArgs, cid, repeatTest) {
    return origFn(specTitle, function (...specFnArgs) {
        return testFnWrapper_1.testFnWrapper.call(this, 'Test', {
            specFn,
            specFnArgs: utils_1.filterSpecArgs(specFnArgs)
        }, {
            beforeFn,
            beforeFnArgs
        }, {
            afterFn,
            afterFnArgs
        }, cid, repeatTest);
    });
};
/**
 * wraps hooks and test function of a framework within a fiber context
 *
 * @param  {Function} origFn               original framework function
 * @param  {Boolean}  isSpec               whether or not origFn is a spec
 * @param  {String[]} testInterfaceFnNames command that runs specs, e.g. `it`, `it.only` or `fit`
 * @param  {Function} beforeFn             before hook
 * @param  {Function} beforeFnArgs         function that returns args for `beforeFn`
 * @param  {Function} afterFn              after hook
 * @param  {Function} afterArgsFn          function that returns args for `afterFn`
 * @param  {String}   cid                  cid
 * @return {Function}                      wrapped test/hook function
 */
exports.wrapTestFunction = function (origFn, isSpec, beforeFn, beforeArgsFn, afterFn, afterArgsFn, cid) {
    return function (...specArguments) {
        /**
         * Variadic arguments:
         * [title, fn], [title], [fn]
         * [title, fn, retryCnt], [title, retryCnt], [fn, retryCnt]
         */
        let retryCnt = typeof specArguments[specArguments.length - 1] === 'number' ? specArguments.pop() : 0;
        const specFn = typeof specArguments[0] === 'function' ? specArguments.shift()
            : (typeof specArguments[1] === 'function' ? specArguments[1] : undefined);
        const specTitle = specArguments[0];
        if (isSpec) {
            if (specFn) {
                return exports.runSpec(specTitle, specFn, origFn, beforeFn, beforeArgsFn, afterFn, afterArgsFn, cid, retryCnt);
            }
            /**
             * if specFn is undefined we are dealing with a pending function
             */
            return origFn(specTitle);
        }
        return exports.runHook(specFn, origFn, beforeFn, beforeArgsFn, afterFn, afterArgsFn, cid, retryCnt);
    };
};
/**
 * Wraps global test function like `it` so that commands can run synchronouse
 *
 * The scope parameter is used in the qunit framework since all functions are bound to global.QUnit instead of global
 *
 * @param  {boolean}  isTest        is `origFn` test function, otherwise hook
 * @param  {Function} beforeFn      before hook
 * @param  {Function} beforeFnArgs  function that returns args for `beforeFn`
 * @param  {Function} afterFn       after hook
 * @param  {Function} afterArgsFn   function that returns args for `afterFn`
 * @param  {String}   fnName        test interface command to wrap, e.g. `beforeEach`
 * @param  {String}   cid           cid
 * @param  {Object}   scope         the scope to run command from, defaults to global
 */
exports.runTestInFiberContext = function (isSpec, beforeFn, beforeArgsFn, afterFn, afterArgsFn, fnName, cid, scope = global) {
    const origFn = scope[fnName];
    scope[fnName] = exports.wrapTestFunction(origFn, isSpec, beforeFn, beforeArgsFn, afterFn, afterArgsFn, cid);
    addMochaCommands(origFn, scope[fnName]);
};
/**
 * support `it.skip` and `it.only` for the Mocha framework
 * @param {Function} origFn original function
 * @param {function} newFn  wrapped function
 */
function addMochaCommands(origFn, newFn) {
    MOCHA_COMMANDS.forEach((commandName) => {
        if (typeof origFn[commandName] === 'function') {
            newFn[commandName] = origFn[commandName];
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdEludGVyZmFjZVdyYXBwZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGVzdC1mcmFtZXdvcmsvdGVzdEludGVyZmFjZVdyYXBwZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRzs7O0FBRUgsb0NBQXlDO0FBQ3pDLG1EQUErQztBQVUvQyxNQUFNLGNBQWMsR0FBcUIsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUE7QUFFekQ7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNVLFFBQUEsT0FBTyxHQUFHLFVBRW5CLE1BQWdCLEVBQ2hCLE1BQWdCLEVBQ2hCLFFBQStCLEVBQy9CLFlBQWlDLEVBQ2pDLE9BQThCLEVBQzlCLFdBQWdDLEVBQ2hDLEdBQVcsRUFDWCxVQUFrQjtJQUVsQixPQUFPLE1BQU0sQ0FBQyxVQUVWLEdBQUcsVUFPRjtRQUVELE9BQU8sNkJBQWEsQ0FBQyxJQUFJLENBQ3JCLElBQUksRUFDSixNQUFNLEVBQ047WUFDSSxNQUFNLEVBQUUsTUFBTTtZQUNkLFVBQVUsRUFBRSxzQkFBYyxDQUFDLFVBQVUsQ0FBQztTQUN6QyxFQUNEO1lBQ0ksUUFBUTtZQUNSLFlBQVk7U0FDZixFQUNEO1lBQ0ksT0FBTztZQUNQLFdBQVc7U0FDZCxFQUNELEdBQUcsRUFDSCxVQUFVLENBQ2IsQ0FBQTtJQUNMLENBQUMsQ0FBQyxDQUFBO0FBQ04sQ0FBQyxDQUFBO0FBRUQ7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNVLFFBQUEsT0FBTyxHQUFHLFVBRW5CLFNBQWlCLEVBQ2pCLE1BQWdCLEVBQ2hCLE1BQWdCLEVBQ2hCLFFBQStCLEVBQy9CLFlBQWlDLEVBQ2pDLE9BQThCLEVBQzlCLFdBQWdDLEVBQ2hDLEdBQVcsRUFDWCxVQUFrQjtJQUVsQixPQUFPLE1BQU0sQ0FBQyxTQUFTLEVBQUUsVUFFckIsR0FBRyxVQU9GO1FBRUQsT0FBTyw2QkFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxFQUNKLE1BQU0sRUFD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