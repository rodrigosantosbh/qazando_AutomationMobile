"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testFrameworkFnWrapper = exports.testFnWrapper = void 0;
const utils_1 = require("../utils");
const errorHandler_1 = require("./errorHandler");
const shim_1 = require("../shim");
/**
 * wraps test framework spec/hook function with WebdriverIO before/after hooks
 *
 * @param   {string} type           Test/Step or Hook
 * @param   {object} spec           specFn and specFnArgs
 * @param   {object} before         beforeFn and beforeFnArgs
 * @param   {object} after          afterFn and afterFnArgs
 * @param   {string} cid            cid
 * @param   {number} repeatTest     number of retries if test fails
 * @return  {*}                     specFn result
 */
exports.testFnWrapper = function (...args) {
    return exports.testFrameworkFnWrapper.call(this, { executeHooksWithArgs: shim_1.executeHooksWithArgs, executeAsync: shim_1.executeAsync, runSync: shim_1.runSync }, ...args);
};
/**
 * wraps test framework spec/hook function with WebdriverIO before/after hooks
 *
 * @param   {object} wrapFunctions  executeHooksWithArgs, executeAsync, runSync
 * @param   {string} type           Test/Step or Hook
 * @param   {object} spec           specFn and specFnArgs array
 * @param   {object} before         beforeFn and beforeFnArgs function
 * @param   {object} after          afterFn and afterFnArgs function
 * @param   {string} cid            cid
 * @param   {number} repeatTest     number of retries if test fails
 * @return  {*}                     specFn result
 */
exports.testFrameworkFnWrapper = async function ({ executeHooksWithArgs, executeAsync, runSync }, type, { specFn, specFnArgs }, { beforeFn, beforeFnArgs }, { afterFn, afterFnArgs }, cid, repeatTest = 0) {
    const retries = { attempts: 0, limit: repeatTest };
    const beforeArgs = beforeFnArgs(this);
    await errorHandler_1.logHookError(`Before${type}`, await executeHooksWithArgs(`before${type}`, beforeFn, beforeArgs), cid);
    let promise;
    let result;
    let error;
    /**
     * user wants handle async command using promises, no need to wrap in fiber context
     */
    if (utils_1.isFunctionAsync(specFn) || !runSync) {
        promise = executeAsync.call(this, specFn, retries, specFnArgs);
    }
    else {
        promise = new Promise(runSync.call(this, specFn, retries, specFnArgs));
    }
    const testStart = Date.now();
    try {
        result = await promise;
    }
    catch (err) {
        error = err;
    }
    const duration = Date.now() - testStart;
    let afterArgs = afterFnArgs(this);
    /**
     * ensure errors are caught in Jasmine tests too
     * (in Jasmine failing assertions are not causing the test to throw as
     * oppose to other common assertion libraries like chai)
     */
    if (!error && afterArgs[0] && afterArgs[0].failedExpectations && afterArgs[0].failedExpectations.length) {
        error = afterArgs[0].failedExpectations[0];
    }
    afterArgs.push({
        retries,
        error,
        result,
        duration,
        passed: !error
    });
    await errorHandler_1.logHookError(`After${type}`, await executeHooksWithArgs(`after${type}`, afterFn, [...afterArgs]), cid);
    if (error) {
        throw error;
    }
    return result;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdEZuV3JhcHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZXN0LWZyYW1ld29yay90ZXN0Rm5XcmFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG9DQUEwQztBQUMxQyxpREFBNkM7QUFDN0Msa0NBQXFFO0FBVXJFOzs7Ozs7Ozs7O0dBVUc7QUFDVSxRQUFBLGFBQWEsR0FBRyxVQUV6QixHQUFHLElBT0Y7SUFFRCxPQUFPLDhCQUFzQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxvQkFBb0IsRUFBcEIsMkJBQW9CLEVBQUUsWUFBWSxFQUFaLG1CQUFZLEVBQUUsT0FBTyxFQUFQLGNBQU8sRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUE7QUFDdEcsQ0FBQyxDQUFBO0FBRUQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDVSxRQUFBLHNCQUFzQixHQUFHLEtBQUssV0FFdkMsRUFBRSxvQkFBb0IsRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFrQixFQUMvRCxJQUFZLEVBQ1osRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFnQixFQUNwQyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQTRCLEVBQ3BELEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBMkIsRUFDakQsR0FBVyxFQUNYLFVBQVUsR0FBRyxDQUFDO0lBRWQsTUFBTSxPQUFPLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsQ0FBQTtJQUNsRCxNQUFNLFVBQVUsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDckMsTUFBTSwyQkFBWSxDQUFDLFNBQVMsSUFBSSxFQUFFLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQyxTQUFTLElBQUksRUFBRSxFQUFFLFFBQVEsRUFBRSxVQUFVLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtJQUUzRyxJQUFJLE9BQU8sQ0FBQTtJQUNYLElBQUksTUFBTSxDQUFBO0lBQ1YsSUFBSSxLQUFLLENBQUE7SUFDVDs7T0FFRztJQUNILElBQUksdUJBQWUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtRQUNyQyxPQUFPLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQTtLQUNqRTtTQUFNO1FBQ0gsT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQTtLQUN6RTtJQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQTtJQUM1QixJQUFJO1FBQ0EsTUFBTSxHQUFHLE1BQU0sT0FBTyxDQUFBO0tBQ3pCO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDVixLQUFLLEdBQUcsR0FBRyxDQUFBO0tBQ2Q7SUFDRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFBO0lBQ3ZDLElBQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUVqQzs7OztPQUlHO0lBQ0gsSUFBSSxDQUFDLEtBQUssSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUssU0FBdUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsSUFBSyxTQUF1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRTtRQUNuSyxLQUFLLEdBQUksU0FBdUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQTtLQUM1RTtJQUVELFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDWCxPQUFPO1FBQ1AsS0FBSztRQUNMLE1BQU07UUFDTixRQUFRO1FBQ1IsTUFBTSxFQUFFLENBQUMsS0FBSztLQUNqQixDQUFDLENBQUE7SUFFRixNQUFNLDJCQUFZLENBQUMsUUFBUSxJQUFJLEVBQUUsRUFBRSxNQUFNLG9CQUFvQixDQUFDLFFBQVEsSUFBSSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0lBRTVHLElBQUksS0FBSyxFQUFFO1FBQ1AsTUFBTSxLQUFLLENBQUE7S0FDZDtJQUNELE9BQU8sTUFBTSxDQUFBO0FBQ2pCLENBQUMsQ0FBQSJ9