"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.canAccess = exports.isBase64 = exports.filterSpecArgs = exports.isFunctionAsync = exports.safeRequire = exports.getArgumentType = exports.isValidParameter = exports.transformCommandLogResult = exports.commandCallStructure = exports.overwriteElementCommands = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const SCREENSHOT_REPLACEMENT = '"<Screenshot[base64]>"';
/**
 * overwrite native element commands with user defined
 * @param {object} propertiesObject propertiesObject
 */
function overwriteElementCommands(propertiesObject) {
    const elementOverrides = propertiesObject['__elementOverrides__'] ? propertiesObject['__elementOverrides__'].value : {};
    for (const [commandName, userDefinedCommand] of Object.entries(elementOverrides)) {
        if (typeof userDefinedCommand !== 'function') {
            throw new Error('overwriteCommand: commands be overwritten only with functions, command: ' + commandName);
        }
        if (!propertiesObject[commandName]) {
            throw new Error('overwriteCommand: no command to be overwritten: ' + commandName);
        }
        if (typeof propertiesObject[commandName].value !== 'function') {
            throw new Error('overwriteCommand: only functions can be overwritten, command: ' + commandName);
        }
        const origCommand = propertiesObject[commandName].value;
        delete propertiesObject[commandName];
        const newCommand = function (...args) {
            const element = this;
            return userDefinedCommand.apply(element, [
                function origCommandFunction() {
                    const context = this || element; // respect explicite context binding, use element as default
                    return origCommand.apply(context, arguments);
                },
                ...args
            ]);
        };
        propertiesObject[commandName] = {
            value: newCommand,
            configurable: true
        };
    }
    delete propertiesObject['__elementOverrides__'];
    propertiesObject['__elementOverrides__'] = { value: {} };
}
exports.overwriteElementCommands = overwriteElementCommands;
/**
 * get command call structure
 * (for logging purposes)
 */
function commandCallStructure(commandName, args) {
    const callArgs = args.map((arg) => {
        if (typeof arg === 'string' && (arg.startsWith('!function(') || arg.startsWith('return (function'))) {
            arg = '<fn>';
        }
        else if (typeof arg === 'string' &&
            /**
             * the isBase64 method returns for xPath values like
             * "/html/body/a" a true value which is why we should
             * include a command check in here.
             */
            !commandName.startsWith('findElement') &&
            isBase64(arg)) {
            arg = SCREENSHOT_REPLACEMENT;
        }
        else if (typeof arg === 'string') {
            arg = `"${arg}"`;
        }
        else if (typeof arg === 'function') {
            arg = '<fn>';
        }
        else if (arg === null) {
            arg = 'null';
        }
        else if (typeof arg === 'object') {
            arg = '<object>';
        }
        else if (typeof arg === 'undefined') {
            arg = typeof arg;
        }
        return arg;
    }).join(', ');
    return `${commandName}(${callArgs})`;
}
exports.commandCallStructure = commandCallStructure;
/**
 * transforms WebDriver result for log stream to avoid unnecessary long
 * result strings e.g. if it contains a screenshot
 * @param {Object} result WebDriver response body
 */
function transformCommandLogResult(result) {
    if (typeof result.file === 'string' && isBase64(result.file)) {
        return SCREENSHOT_REPLACEMENT;
    }
    return result;
}
exports.transformCommandLogResult = transformCommandLogResult;
/**
 * checks if command argument is valid according to specificiation
 *
 * @param  {*}       arg           command argument
 * @param  {Object}  expectedType  parameter type (e.g. `number`, `string[]` or `(number|string)`)
 * @return {Boolean}               true if argument is valid
 */
function isValidParameter(arg, expectedType) {
    let shouldBeArray = false;
    if (expectedType.slice(-2) === '[]') {
        expectedType = expectedType.slice(0, -2);
        shouldBeArray = true;
    }
    /**
     * check type of each individual array element
     */
    if (shouldBeArray) {
        if (!Array.isArray(arg)) {
            return false;
        }
    }
    else {
        /**
         * transform to array to have a unified check
         */
        arg = [arg];
    }
    for (const argEntity of arg) {
        const argEntityType = getArgumentType(argEntity);
        if (!argEntityType.match(expectedType)) {
            return false;
        }
    }
    return true;
}
exports.isValidParameter = isValidParameter;
/**
 * get type of command argument
 */
function getArgumentType(arg) {
    return arg === null ? 'null' : typeof arg;
}
exports.getArgumentType = getArgumentType;
/**
 * Allows to safely require a package, it only throws if the package was found
 * but failed to load due to syntax errors
 * @param  {string} name  of package
 * @return {object}       package content
 */
function safeRequire(name) {
    var _a, _b, _c;
    let requirePath;
    try {
        /**
         * Check if cli command was called from local directory, if not require
         * the plugin from the place where the command is called. This avoids
         * issues where user have the @wdio/cli package installed globally
         * but run on a project where wdio packages are installed locally. It
         * also allows to link the package to a random place and have plugins
         * imported correctly (for dev purposes).
         */
        const localNodeModules = path_1.default.join(process.cwd(), '/node_modules');
        /* istanbul ignore if */
        if (!((_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.paths.includes(localNodeModules))) {
            (_b = require === null || require === void 0 ? void 0 : require.main) === null || _b === void 0 ? void 0 : _b.paths.push(localNodeModules);
            /**
             * don't set requireOpts when running unit tests as it
             * confuses Jest require magic
             */
            const requireOpts = process.env.JEST_WORKER_ID
                ? {}
                : { paths: (_c = require === null || require === void 0 ? void 0 : require.main) === null || _c === void 0 ? void 0 : _c.paths };
            requirePath = require.resolve(name, requireOpts);
        }
        else {
            requirePath = require.resolve(name);
        }
    }
    catch (e) {
        return null;
    }
    try {
        return require(requirePath);
    }
    catch (e) {
        throw new Error(`Couldn't initialise "${name}".\n${e.stack}`);
    }
}
exports.safeRequire = safeRequire;
/**
 * is function async
 * @param  {Function} fn  function to check
 * @return {Boolean}      true provided function is async
 */
function isFunctionAsync(fn) {
    return (fn.constructor && fn.constructor.name === 'AsyncFunction') || fn.name === 'async';
}
exports.isFunctionAsync = isFunctionAsync;
/**
 * filter out arguments passed to specFn & hookFn, don't allow callbacks
 * as there is no need for user to call e.g. `done()`
 */
function filterSpecArgs(args) {
    return args.filter((arg) => typeof arg !== 'function');
}
exports.filterSpecArgs = filterSpecArgs;
/**
 * checks if provided string is Base64
 * @param  {String} str  string in base64 to check
 * @return {Boolean} true if the provided string is Base64
 */
function isBase64(str) {
    var notBase64 = new RegExp('[^A-Z0-9+\\/=]', 'i');
    if (typeof str !== 'string') {
        throw new Error('Expected string but received invalid type.');
    }
    const len = str.length;
    if (!len || len % 4 !== 0 || notBase64.test(str)) {
        return false;
    }
    const firstPaddingChar = str.indexOf('=');
    return firstPaddingChar === -1 ||
        firstPaddingChar === len - 1 ||
        (firstPaddingChar === len - 2 && str[len - 1] === '=');
}
exports.isBase64 = isBase64;
/**
 * Helper utility to check file access
 * @param {String} file file to check access for
 * @return              true if file can be accessed
 */
exports.canAccess = (file) => {
    if (!file) {
        return false;
    }
    try {
        fs_1.default.accessSync(file);
        return true;
    }
    catch (e) {
        return false;
    }
};
/**
 * sleep
 * @param {number=0} ms number in ms to sleep
 */
exports.sleep = (ms = 0) => new Promise((r) => setTimeout(r, ms));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNENBQW1CO0FBQ25CLGdEQUF1QjtBQUl2QixNQUFNLHNCQUFzQixHQUFHLHdCQUF3QixDQUFBO0FBRXZEOzs7R0FHRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLGdCQUFpRjtJQUN0SCxNQUFNLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7SUFFdkgsS0FBSyxNQUFNLENBQUMsV0FBVyxFQUFFLGtCQUFrQixDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1FBQzlFLElBQUksT0FBTyxrQkFBa0IsS0FBSyxVQUFVLEVBQUU7WUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQywwRUFBMEUsR0FBRyxXQUFXLENBQUMsQ0FBQTtTQUM1RztRQUVELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxHQUFHLFdBQVcsQ0FBQyxDQUFBO1NBQ3BGO1FBRUQsSUFBSSxPQUFPLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssS0FBSyxVQUFVLEVBQUU7WUFDM0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxnRUFBZ0UsR0FBRyxXQUFXLENBQUMsQ0FBQTtTQUNsRztRQUVELE1BQU0sV0FBVyxHQUFHLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQTtRQUN2RCxPQUFPLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFBO1FBRXBDLE1BQU0sVUFBVSxHQUFHLFVBQWlDLEdBQUcsSUFBVztZQUM5RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUE7WUFD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